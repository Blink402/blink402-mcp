import { Connection, PublicKey, Transaction, TransactionInstruction, Keypair } from '@solana/web3.js';
export { verifyPaymentWithSolanaPay, findTransactionByReference, validateTransferWithRetry, type PaymentVerificationOptions, type PaymentVerificationResult, } from './solana-pay-verification';
export { withExponentialBackoff, retrySolanaRpc, withTimeout, sleep, type RetryOptions, } from './retry-utils';
export { extractPayerFromTransaction, extractPayerWithRetry, type ExtractedPayerInfo } from './extract-payer';
export { buildUsdcPaymentTransaction, validateWalletAddress, getUsdcMintForNetwork, usdcToAtomic, atomicToUsdc, type BuildUsdcPaymentTxParams } from './transaction-builder';
export { getB402HolderTier, applyB402Discount, getTierDisplayInfo, getTierThresholds, getAllTierBenefits, getRemainingFreeSpins, validateB402Mint, B402_MINT, B402_DECIMALS, type TokenHolderTier, type TokenHolderInfo, type TokenBenefits, } from './token-holder';
export { detectSpamToken, detectSpamTokens, getRiskLevelDescription, getRiskLevelEmoji, getRiskLevelColor, type SpamRiskLevel, type SpamDetectionResult, type TokenForSpamCheck, } from './spam-detector';
/**
 * Get the correct USDC mint address for the current network
 * Supports custom USDC mint via NEXT_PUBLIC_USDC_MINT env var
 */
export declare function getUsdcMint(network?: 'devnet' | 'mainnet-beta'): PublicKey;
export declare const USDC_MINT: PublicKey;
export declare const USDC_DECIMALS = 6;
export declare const SOL_DECIMALS = 9;
export declare const LAMPORTS_PER_SOL = 1000000000;
export declare function getConnection(): Connection;
export declare function solToLamports(amount: string | number): bigint;
export declare function lamportsToSol(lamports: bigint | number): string;
export declare function usdcToLamports(amount: string | number): bigint;
export declare function lamportsToUsdc(lamports: bigint | number): string;
export declare function getOrCreateTokenAccount(connection: Connection, payer: PublicKey, owner: PublicKey, mint?: PublicKey): Promise<{
    address: PublicKey;
    instruction?: TransactionInstruction;
}>;
/**
 * @deprecated This function was used for server-side transaction building in Solana Actions.
 * The ONCHAIN x402 flow uses client-side transaction building instead.
 * For charge mode: Build transactions client-side in the frontend (see apps/web/app/checkout/page.tsx)
 * For reward mode: Use buildRewardTransaction() instead
 *
 * Kept for backwards compatibility with fallback proxy only.
 */
export declare function buildSolTransferTransaction(params: {
    connection: Connection;
    sender: PublicKey;
    recipient: PublicKey;
    amount: bigint;
    reference: PublicKey;
    memo?: string;
    platformWallet?: PublicKey;
    platformFeeBps?: number;
}): Promise<Transaction>;
/**
 * @deprecated This function was used for server-side transaction building in Solana Actions.
 * The ONCHAIN x402 flow uses client-side transaction building instead.
 * For charge mode: Build transactions client-side in the frontend (see apps/web/app/checkout/page.tsx)
 * For reward mode: Use buildRewardTransaction() instead
 *
 * Kept for backwards compatibility with fallback proxy only.
 */
export declare function buildUsdcTransferTransaction(params: {
    connection: Connection;
    sender: PublicKey;
    recipient: PublicKey;
    amount: bigint;
    reference: PublicKey;
    memo?: string;
    platformWallet?: PublicKey;
    platformFeeBps?: number;
}): Promise<Transaction>;
/**
 * Build a REWARD transaction where creator pays the user
 * Used for "reward mode" blinks where users get paid for completing actions
 *
 * @param params.connection - Solana connection
 * @param params.creator - Creator's wallet (sender, pays fees + reward)
 * @param params.user - User's wallet (recipient)
 * @param params.amount - Reward amount in lamports
 * @param params.reference - Reference keypair for tracking
 * @param params.memo - Optional memo
 * @param params.tokenMint - Optional token mint (undefined for SOL, USDC mint for USDC)
 * @returns Unsigned transaction (must be signed by creator server-side)
 */
export declare function buildRewardTransaction(params: {
    connection: Connection;
    creator: PublicKey;
    user: PublicKey;
    amount: bigint;
    reference?: PublicKey;
    memo?: string;
    tokenMint?: PublicKey;
}): Promise<Transaction>;
/**
 * Sign and broadcast a reward transaction with retry logic
 * SECURITY CRITICAL: Creator keypair must be securely managed
 *
 * @param params.connection - Solana connection
 * @param params.transaction - Unsigned reward transaction
 * @param params.creatorKeypair - Creator's keypair (from secure storage)
 * @param params.skipConfirmation - Skip waiting for confirmation (faster for concurrent claims)
 * @returns Transaction signature
 */
export declare function signAndBroadcastReward(params: {
    connection: Connection;
    transaction: Transaction;
    creatorKeypair: Keypair;
    skipConfirmation?: boolean;
}): Promise<string>;
/**
 * Build a REFUND transaction where platform refunds the user
 * Used when API execution fails after successful payment
 *
 * @param params.connection - Solana connection
 * @param params.platformWallet - Platform refund wallet (sender, pays fees)
 * @param params.user - User's wallet (recipient of refund)
 * @param params.amount - Refund amount in lamports (typically matches original payment)
 * @param params.reference - Original reference keypair for tracking
 * @param params.memo - Optional memo (e.g., "Refund for failed API execution")
 * @param params.tokenMint - Token mint (undefined for SOL, USDC mint for USDC)
 * @returns Unsigned transaction (must be signed by platform keypair server-side)
 */
export declare function buildRefundTransaction(params: {
    connection: Connection;
    platformWallet: PublicKey;
    user: PublicKey;
    amount: bigint;
    reference: PublicKey;
    memo?: string;
    tokenMint?: PublicKey;
}): Promise<Transaction>;
/**
 * Sign and broadcast a refund transaction
 * SECURITY CRITICAL: Platform refund keypair must be securely managed
 *
 * @param params.connection - Solana connection
 * @param params.transaction - Unsigned refund transaction
 * @param params.platformKeypair - Platform's refund keypair (from secure storage/env var)
 * @returns Transaction signature
 */
export declare function executeRefund(params: {
    connection: Connection;
    transaction: Transaction;
    platformKeypair: Keypair;
}): Promise<string>;
/**
 * Verify a refund transaction was confirmed on-chain
 * Similar to verifyPayment but with less strict validation (just check it exists and succeeded)
 *
 * @param params.connection - Solana connection
 * @param params.signature - Refund transaction signature
 * @returns Transaction details
 */
export declare function verifyRefundTransaction(params: {
    connection: Connection;
    signature: string;
}): Promise<{
    signature: string;
    confirmed: boolean;
    timestamp: number;
}>;
/**
 * Verify a payment transaction on-chain
 *
 * IMPORTANT: This function does NOT use @solana/pay's validateTransfer or findReference
 * because they fail with StructError on null costUnits in modern Solana RPC responses.
 * We use custom validation functions instead that parse transaction balances directly.
 *
 * @see findReferenceWithoutValidation - Custom reference finder
 * @see validateTransferManually - Custom transfer validator
 */
export declare function verifyPayment(params: {
    connection: Connection;
    reference: PublicKey;
    recipient: PublicKey;
    amount: bigint;
    splToken?: PublicKey;
    timeout?: number;
}): Promise<{
    signature: string;
    amount: bigint;
    timestamp: number;
}>;
export declare function waitForPayment(params: {
    connection: Connection;
    reference: PublicKey;
    recipient: PublicKey;
    amount: bigint;
    splToken?: PublicKey;
    timeout?: number;
    onProgress?: (elapsed: number) => void;
}): Promise<{
    signature: string;
    amount: bigint;
    timestamp: number;
}>;
export declare function generateReference(): Keypair;
export declare function parsePublicKey(key: string): PublicKey | null;
export declare function isValidSolanaAddress(address: string): boolean;
export declare function getExplorerUrl(signature: string, cluster?: 'mainnet-beta' | 'devnet' | 'testnet'): string;
export declare function formatPublicKey(key: PublicKey | string, chars?: number): string;
/**
 * Check if payment verification is in mock mode
 * Mock mode bypasses actual on-chain verification for testing
 * NEVER returns true in production (safety check in verifyPayment)
 */
export declare function isMockPaymentsEnabled(): boolean;
/**
 * Verify that a message was signed by a specific wallet
 * Used for reward blinks to prevent spam/bot attacks
 *
 * @param message - The original message that was signed (e.g., challenge string)
 * @param signature - The signature as base58 string or Uint8Array
 * @param publicKey - The wallet's public key (expected signer)
 * @returns true if signature is valid, false otherwise
 */
export declare function verifyMessageSignature(message: string, signature: string | Uint8Array, publicKey: string | PublicKey): boolean;
/**
 * Generate a challenge message for wallet signature
 * Used in reward blinks to prevent replay attacks
 *
 * @param params - Challenge parameters
 * @returns Challenge string to be signed by user's wallet
 */
export declare function generateChallengeMessage(params: {
    wallet: string;
    blinkId: string | number;
    nonce: string;
    timestamp: number;
}): string;
//# sourceMappingURL=index.d.ts.map